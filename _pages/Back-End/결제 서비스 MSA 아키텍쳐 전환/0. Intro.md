---
title: "0. Intro: 결제 서비스 MSA 전환 여정"
date: "2025-09-01"
tags:
    - Spring Boot 3.4.0
    - Java 21
    - MySQL 8
    - JPA
    - MSA
    - Architecture
---

> **모놀리식에서 마이크로서비스로: 결제 서비스 독립화 프로젝트**
>
> Common 모듈에 강하게 결합된 결제 서비스를 독립된 MSA로 전환하여 리소스 효율성과 유지보수성을 향상시킨 과정을 다룹니다.

---

## 🎯 현재 상황 분석

### 비즈니스 맥락

우리는 **가맹점과 소비자를 연결하는 플랫폼**에서 PG사 API와 연동하여 결제 서비스를 제공하고 있습니다.

#### 제공하는 기능
- 💳 **결제 수단 관리**: 등록, 삭제, 조회
- 💰 **결제 처리**: 자동 결제, 카카오톡 청구서 발송
- 🔄 **환불 및 재결제**: 취소 및 재요청 처리
- 📊 **결제 이력 관리**: 전체 결제 프로세스 추적

---

## 🔄 결제 프로세스 Flow

### 1️⃣ 결제 요청 수신

```
가맹점 → [플랫폼] → 책정 금액 + 소비자 정보
```

가맹점이 서비스 이용 금액을 책정하여 전달

### 2️⃣ 결제 방식 결정 로직

```typescript
if (소비자.isAppMember) {
  if (소비자.hasRegisteredPaymentMethod) {
    // ✅ Case 1: 자동 결제
    결제수단으로_즉시_결제();
  } else {
    // ⚠️ Case 2: 결제 수단 없음
    카카오톡_청구서_발송();
  }
} else {
  // 📱 Case 3: 비회원
  카카오톡_청구서_발송();
}
```

#### Case 1: 자동 결제 (회원 + 등록된 결제 수단)
- PG사의 **자동 결제 시스템** 활용
- 사전 등록된 결제 수단으로 즉시 결제 요청

#### Case 2: 청구서 발송 (회원 + 결제 수단 없음/문제)
- 소비자 연락처로 **카카오톡 청구서** 전송
- 소비자가 직접 결제 수단 선택 및 결제

#### Case 3: 비회원 청구서
- 즉시 카카오톡 청구서 방식 사용

### 3️⃣ 결제 결과 수신

```
PG사 → Callback API → [플랫폼] → 결제 결과 처리
```

- PG사로부터 **Webhook** 방식으로 결과 수신
- 성공/실패 여부에 따른 후속 처리

### 4️⃣ 환불 및 재결제

```java
// 환불 프로세스
환불요청(청구서ID, 환불금액);

// 재결제 프로세스
환불요청();
새로운_청구서_생성();
결제요청(새청구서ID);
```

---

## 🚨 기존 아키텍처의 문제점

### 1️⃣ 강한 결합도 (Tight Coupling)

```
┌─────────────────────────────────────┐
│         Common 모듈                  │
├─────────────────────────────────────┤
│  - User Service                     │
│  - Payment Service  ← 여기!         │
│  - Notification Service             │
│  - ...                              │
└─────────────────────────────────────┘
         ↑     ↑     ↑     ↑
         │     │     │     │
    ┌────┴─┬───┴─┬───┴─┬───┴────┐
    │ App A│App B│App C│ App D  │
    └──────┴─────┴─────┴────────┘
```

**문제:**
- ❌ **모든 모듈이 Common을 의존**
- ❌ 결제 서비스가 필요 없는 모듈도 **인스턴스 생성**
- ❌ Payment Service 변경 시 **전체 재배포** 필요
- ❌ 리소스 낭비 및 배포 리스크 증가

### 2️⃣ 리소스 비용 증가

```plaintext
기존 구조에서 각 서비스 인스턴스:
┌──────────────────────────────────┐
│ App Instance                     │
├──────────────────────────────────┤
│ - 필수: Common (Payment 포함)    │
│ - 메모리: ~150MB (Payment 30MB)  │
│ - CPU: 일정량 할당               │
└──────────────────────────────────┘

총 10개 인스턴스 × 30MB = 300MB 낭비
```

### 3️⃣ 유지보수 어려움

- 🔴 결제 로직 변경 시 영향 범위 파악 어려움
- 🔴 테스트 범위 확대 (전체 Common 모듈)
- 🔴 결제 서비스만 독립적으로 스케일링 불가

---

## 🎯 MSA 전환 목표

### 핵심 목표

#### 1️⃣ 독립성 확보
```
Before: Common → Payment (내부)
After:  Payment Service (독립)
```

- ✅ 결제 서비스 **독립 배포**
- ✅ 다른 서비스에 영향 없이 **버전 업그레이드**
- ✅ 장애 격리 (Circuit Breaker)

#### 2️⃣ 의존성 감소

```java
// Before: 강한 의존성
@Autowired
private PaymentService paymentService; // Common 모듈 내부

// After: 느슨한 결합
@FeignClient("payment-service")
interface PaymentClient {
  PaymentResponse processPayment(PaymentRequest request);
}
```

#### 3️⃣ 유지보수성 향상

- 📝 **명확한 책임 분리**: 결제 로직만 집중
- 🧪 **테스트 용이성**: 결제 서비스만 독립 테스트
- 🔧 **빠른 배포**: 다른 서비스 영향 없음

#### 4️⃣ 확장성 개선

```
기존: 전체 스케일 아웃 필요
MSA: 결제 서비스만 선택적 스케일링

Payment Service: ■■■■■ (5 instances)
User Service:    ■■    (2 instances)
Notification:    ■■    (2 instances)
```

---

## 🏗️ 설계 원칙

### 1. 어댑터 패턴 적용

```java
// Port (인터페이스)
public interface PaymentPort {
  PaymentResponse payment(PaymentRequest request);
}

// Adapter (구현체)
public class TossPaymentAdapter implements PaymentPort {
  @Override
  public PaymentResponse payment(PaymentRequest request) {
    // Toss PG사 연동 로직
  }
}

public class NicePaymentAdapter implements PaymentPort {
  @Override
  public PaymentResponse payment(PaymentRequest request) {
    // Nice PG사 연동 로직
  }
}
```

**장점:**
- 🔄 PG사 교체 시 **Adapter만 변경**
- ➕ 신규 PG사 추가 용이
- 🧪 Mock Adapter로 테스트 간편

참고: [어댑터 패턴 (Adapter Pattern) 이란?](https://jake-seo-dev.tistory.com/379)

### 2. 데이터 분리 전략

#### 기존 구조 (AS-IS)
```
┌─────────────────────────────────┐
│     Main Schema                 │
├─────────────────────────────────┤
│ - Users                         │
│ - Orders                        │
│ - Payments   ← 모두 한 곳에     │
│ - Payment Methods               │
│ - Payment History               │
└─────────────────────────────────┘
```

#### 개선 구조 (TO-BE)
```
┌──────────────────┐   ┌──────────────────┐
│  Main Schema     │   │ Payment Schema   │
├──────────────────┤   ├──────────────────┤
│ - Users          │   │ - Transactions   │
│ - Orders         │   │ - Methods        │
│ - Payment Mapping│───│ - History        │
│   (연결 테이블)  │   │ - PG Logs        │
└──────────────────┘   └──────────────────┘
```

### 3. VIEW TABLE 제거

**기존 문제:**
- ❌ 복잡한 JOIN으로 인한 성능 저하
- ❌ VIEW 변경 시 영향 범위 파악 어려움

**개선 방향:**
- ✅ 필요한 데이터만 API로 조회
- ✅ 애플리케이션 레벨에서 데이터 조합
- ✅ 캐싱 전략으로 성능 보완

### 4. 스키마 분리 전략

#### Payment Schema (독립)
```sql
-- PG사 원시 데이터만 저장
CREATE TABLE payment_transactions (
  id BIGINT PRIMARY KEY,
  pg_transaction_id VARCHAR(100),
  amount DECIMAL(15,2),
  status VARCHAR(20),
  pg_request JSON,   -- 원본 요청 데이터
  pg_response JSON,  -- 원본 응답 데이터
  created_at TIMESTAMP
);
```

#### Main Schema (매핑)
```sql
-- 도메인별 결제 연결 정보
CREATE TABLE order_payment_mapping (
  id BIGINT PRIMARY KEY,
  order_id BIGINT,
  payment_id BIGINT,  -- Payment Schema의 ID 참조
  status VARCHAR(20),
  created_at TIMESTAMP
);
```

**장점:**
- 🔒 결제 서비스만 Payment Schema 접근
- 🔗 느슨한 결합 (ID 참조만)
- 📊 각 도메인이 독립적으로 상태 관리

---

## 📋 전환 시리즈 구성

본 MSA 전환 프로젝트는 다음 순서로 진행됩니다:

### 📚 시리즈 목차

1. **[Legacy DB 테이블 정리](/Back-End/결제-서비스-MSA-아키텍쳐-전환/1-Legacy-DB-테이블-정리)**
   - 기존 테이블 Drop
   - 신규 스키마 및 테이블 Create
   - 매핑 테이블 설계

2. **[어댑터 패턴 설계](/Back-End/결제-서비스-MSA-아키텍쳐-전환/2-어댑터-패턴-설계)**
   - Port 인터페이스 정의
   - 다형성을 활용한 PG사 추상화

3. **[어댑터 구현체 설계](/Back-End/결제-서비스-MSA-아키텍쳐-전환/3-어댑터-구현체-설계)**
   - 실제 PG사 연동 Adapter 구현
   - 에러 핸들링 및 재시도 로직

4. **[PG사 외부 API 요청 RestClient](/Back-End/결제-서비스-MSA-아키텍쳐-전환/4-PG사-외부-API-요청-RestClient)**
   - Spring Boot 3.x RestClient 활용
   - HTTP 통신 및 타임아웃 설정

5. **[Runnable 패턴 구현](/Back-End/결제-서비스-MSA-아키텍쳐-전환/5-Runnable-패턴-구현)**
   - 성공/실패 콜백 처리
   - 트랜잭션 관리

6. **[인터페이스 추상화](/Back-End/결제-서비스-MSA-아키텍쳐-전환/6-인터페이스-추상화)**
   - 최종 구조 정리
   - 확장 포인트 설계

---

## 🎯 기대 효과

### 1️⃣ 리소스 효율성

| 항목 | Before | After | 개선율 |
|------|--------|-------|--------|
| 메모리 사용량 | ~300MB 낭비 | 독립 관리 | **100%** |
| 배포 시간 | 전체 재배포 (10분) | 결제만 배포 (2분) | **80% ↓** |
| 인스턴스 비용 | 불필요한 할당 | 필요 시만 스케일링 | **~40% ↓** |

### 2️⃣ 개발 생산성

- ✅ 결제 로직 변경 시 **영향 범위 명확**
- ✅ **독립적인 테스트** 가능
- ✅ **빠른 배포 주기** (CI/CD 최적화)

### 3️⃣ 시스템 안정성

- 🛡️ **장애 격리**: 결제 서비스 장애가 다른 서비스에 영향 없음
- 🔄 **무중단 배포**: Blue-Green 배포 가능
- 📈 **모니터링 개선**: 결제 서비스만 집중 모니터링

### 4️⃣ 비즈니스 민첩성

- 🚀 신규 PG사 추가 용이
- 🔧 A/B 테스트 가능 (PG사별 분기)
- 📊 결제 데이터 분석 독립화

---

## 💡 핵심 교훈

### 설계 단계에서 고려할 점

1. **명확한 책임 분리**
   - 각 서비스가 담당할 범위를 명확히 정의
   - 도메인 경계 (Bounded Context) 설정

2. **데이터 소유권**
   - 각 서비스가 자신의 데이터베이스 소유
   - 타 서비스 DB 직접 접근 금지

3. **통신 방식 결정**
   - 동기(REST) vs 비동기(Message Queue)
   - 트랜잭션 범위 고려

4. **점진적 전환**
   - 한 번에 전체 전환하지 않고 단계적 마이그레이션
   - Strangler Fig 패턴 적용 고려

---

## 🚀 다음 단계

[1. Legacy DB 테이블 정리](/Back-End/결제-서비스-MSA-아키텍쳐-전환/1-Legacy-DB-테이블-정리)로 이동하여 데이터베이스 분리 작업부터 시작합니다.

**Let's dive in!** 💪